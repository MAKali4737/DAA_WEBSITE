<div id="city">
<table>
<tbody><tr><td>

<h1 class="h1">Algorithm Design Techniques</h1>
<p>The following is a list of several popular design approaches:</p>
<p><strong>1. Divide and Conquer Approach:</strong> It is a top-down approach. The algorithms which follow the divide &amp; conquer techniques involve three steps:</p>
<ul class="points">
<li>Divide the original problem into a set of subproblems.</li>
<li>Solve every subproblem individually, recursively.</li>
<li>Combine the solution of the subproblems (top level) into a solution of the whole original problem.</li>
</ul>
<p><strong>2. Greedy Technique:</strong> Greedy method is used to solve the optimization problem. An optimization problem is one in which we are given a set of input values, which are required either to be maximized or minimized (known as objective), i.e. some constraints or conditions.</p><div style="display: block; clear: both; text-align: center; margin: 0px auto 40px; position: relative;" id="1bd7736f-7392-442c-8af5-f7439cb63894" data-section="1bd7736f-7392-442c-8af5-f7439cb63894" class="_ap_apex_ad" data-xpath="#city > table:eq(0) > tbody:eq(0) > tr:eq(0) > td:eq(0) > p:eq(2)" data-section-id="" data-render-time="1585395260911" data-refresh-time="1585395260914" data-timeout="13"><div id="ADP_37780_336X280_1bd7736f-7392-442c-8af5-f7439cb63894" style="margin: 0 auto">
<script type="text/javascript">
window.adpushup.adpTags.que.push(function(){
window.adpushup.adpTags.display("ADP_37780_336X280_1bd7736f-7392-442c-8af5-f7439cb63894");
});
</script>
</div></div>
<ul class="points">
<li>Greedy Algorithm always makes the choice (greedy criteria) looks best at the moment, to optimize a given objective.</li>
<li>The greedy algorithm doesn't always guarantee the optimal solution however it generally produces a solution that is very close in value to the optimal.</li>
</ul>
<p><strong>3. Dynamic Programming:</strong> Dynamic Programming is a bottom-up approach we solve all possible small problems and then combine them to obtain solutions for bigger problems.</p>
<p>This is particularly helpful when the number of copying subproblems is exponentially large. Dynamic Programming is frequently related to <strong>Optimization Problems</strong>. </p>
<p><strong>4. Branch and Bound:</strong> In Branch &amp; Bound algorithm a given subproblem, which cannot be bounded, has to be divided into at least two new restricted subproblems. Branch and Bound algorithm are methods for global optimization in non-convex problems. Branch and Bound algorithms can be slow, however in the worst case they require effort that grows exponentially with problem size, but in some cases we are lucky, and the method coverage with much less effort.</p>
<p><strong>5. Randomized Algorithms:</strong> A randomized algorithm is defined as an algorithm that is allowed to access a source of independent, unbiased random bits, and it is then allowed to use these random bits to influence its computation.</p>
<p><strong>6. Backtracking Algorithm:</strong> Backtracking Algorithm tries each possibility until they find the right one. It is a depth-first search of the set of possible solution. During the search, if an alternative doesn't work, then backtrack to the choice point, the place which presented different alternatives, and tries the next alternative. </p>    
<p><strong>7. Randomized Algorithm:</strong> A randomized algorithm uses a random number at least once during the computation make a decision.</p>
<p><strong>Example 1:</strong> In Quick Sort, using a random number to choose a pivot.</p>
<p><strong>Example 2:</strong> Trying to factor a large number by choosing a random number as possible divisors.</p>
<hr>

<h2 class="h3">Loop invariants</h2>
<p>This is a justification technique. We use loop invariant that helps us to understand why an algorithm is correct. To prove statement S about a loop is correct, define S concerning series of smaller statement S<sub>0</sub> S<sub>1</sub>....S<sub>k</sub> where,</p>
<ul class="points">
<li>The initial claim so is true before the loop begins.</li>
<li>If S<sub>i-1</sub> is true before iteration i begin, then one can show that S<sub>i</sub>  will be true after iteration i is over.</li>
<li>The final statement S<sub>k</sub> implies the statement S that we wish to justify as being true.</li>
</ul>



<br><br>

<br><br>
</td></tr>
</tbody></table>
</div>