<div id="city">
<table>
<tbody><tr><td>


<h1 class="h1">Linear Time Sorting</h1>
<p>We have sorting algorithms that can sort "n" numbers in O (n log n) time.</p>
<p>Merge Sort and Heap Sort achieve this upper bound in the worst case, and Quick Sort achieves this on Average Case.</p>
<p>Merge Sort, Quick Sort and Heap Sort algorithm share an interesting property: the sorted order they determined is based only on comparisons between the input elements. We call such a sorting algorithm <strong>"Comparison Sort"</strong>.</p><div style="display: block; clear: both; text-align: center; margin: 0px auto 40px; position: relative;" id="1bd7736f-7392-442c-8af5-f7439cb63894" data-section="1bd7736f-7392-442c-8af5-f7439cb63894" class="_ap_apex_ad" data-xpath="#city > table:eq(0) > tbody:eq(0) > tr:eq(0) > td:eq(0) > p:eq(2)" data-section-id="" data-render-time="1585399502955" data-refresh-time="1585399502959" data-timeout="8"><div id="ADP_37780_336X280_1bd7736f-7392-442c-8af5-f7439cb63894" style="margin: 0 auto">
<script type="text/javascript">
window.adpushup.adpTags.que.push(function(){
window.adpushup.adpTags.display("ADP_37780_336X280_1bd7736f-7392-442c-8af5-f7439cb63894");
});
</script>
</div></div> 
<p>There is some algorithm that runs faster and takes linear time such as Counting Sort, Radix Sort, and Bucket Sort but they require the special assumption about the input sequence to sort.</p>
<p><strong>Counting Sort and Radix Sort</strong> assumes that the input consists of an integer in a small range.</p>
<p><strong>Bucket Sort</strong> assumes that a random process that distributes elements uniformly over the interval generates the input.</p>

<hr>

<br><br>

<br><br>
</td></tr>
</tbody></table>
</div>